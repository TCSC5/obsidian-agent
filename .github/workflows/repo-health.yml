name: Repo health audit

on:
  workflow_dispatch:
  schedule:
    - cron: "0 10 * * 1" # Mondays 10:00 UTC

permissions:
  contents: read
  security-events: read
  pull-requests: write   # only to post a summary comment
  issues: write          # only to post a summary comment

jobs:
  labels-and-config:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5 pinned
      - name: Check required labels exist (canonical + legacy)
        uses: actions/github-script@e69ef5465b70a5f9a6f88d677f2b5a9f3e4b603a # v7 pinned
        with:
          script: |
            const required = new Set([
              "deps","ci","security","automerge",
              "priority:P0","priority:P1","priority:P2",
              "status:needs-triage","status:needs-info","status:in-progress","status:blocked","status:ready-to-merge",
              "type:bug","type:feature","type:docs","type:test","type:refactor","type:chore","type:perf",
              "breaking-change","release:major","release:minor","release:patch","backport",
              // legacy labels your agents may still read:
              "bug","documentation","enhancement","duplicate","wontfix","invalid","question"
            ]);
            const { data: labels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner, repo: context.repo.repo, per_page: 200
            });
            const have = new Set(labels.map(l => l.name));
            const missing = [...required].filter(n => !have.has(n));
            if (missing.length) {
              core.setFailed(`Missing labels: ${missing.join(", ")}`);
            } else {
              core.notice("All required labels present.");
            }

      - name: Validate dependabot.yml is present and sensible
        shell: bash
        run: |
          set -euo pipefail
          test -f .github/dependabot.yml || { echo "::error ::.github/dependabot.yml not found"; exit 1; }
          # Basic checks
          grep -q 'package-ecosystem: "pip"' .github/dependabot.yml || { echo "::error ::pip ecosystem missing"; exit 1; }
          grep -q 'package-ecosystem: "github-actions"' .github/dependabot.yml || { echo "::error ::github-actions ecosystem missing"; exit 1; }
          grep -q 'groups:' .github/dependabot.yml || echo "::warning ::No groups configured (you may get more PRs)."
          grep -q 'labels: \\["deps' .github/dependabot.yml || echo "::warning ::Dependabot PRs not labeled 'deps'."
          echo "dependabot.yml found and parsed."

      - name: Check dependency-submission workflow exists
        shell: bash
        run: |
          set -euo pipefail
          if ! grep -Rql 'python-dependency-submission' .github/workflows 2>/dev/null; then
            echo "::warning ::No dependency-submission workflow found (transitives may not be submitted)."
          else
            echo "Dependency submission workflow present."
          fi

  actions-pinning:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
      - name: Fail on unpinned GitHub Actions
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(.github/workflows/*.yml)
          [ ${#files[@]} -gt 0 ] || exit 0
          bad=0
          for f in "${files[@]}"; do
            # allow pinned SHAs (40 hex) and local actions; flag @v* or @main/master
            if grep -E 'uses:\s*[^@]+@v[0-9]' "$f" || grep -E 'uses:\s*[^@]+@(main|master)$' "$f"; then
              echo "::error file=$f::Unpinned action reference (use commit SHA)."
              bad=1
            fi
          done
          exit $bad

  resource-yaml-lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
      - uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c
        with: { python-version: '3.11' }
      - name: Lint resource front-matter
        shell: bash
        run: |
          set -euo pipefail
          pip install python-frontmatter
          python - <<'PY'
          import sys, pathlib, frontmatter, re
          ROOT = pathlib.Path("Resources/learning_inputs")
          required = {"title", "type", "domain", "tags"}
          missing_any = False
          if not ROOT.exists():
              print("::notice ::Resources/learning_inputs/ not present (skip).")
              sys.exit(0)
          for p in ROOT.rglob("*.md"):
              post = frontmatter.load(p)
              keys = set(post.keys())
              if not required.issubset(keys):
                  missing = required - keys
                  print(f"::error file={p}::Missing front-matter keys: {', '.join(missing)}")
                  missing_any = True
              if post.get("type") != "resource":
                  print(f"::error file={p}::type should be 'resource'")
                  missing_any = True
              tags = post.get("tags") or []
              if not isinstance(tags, (list, tuple)) or len(tags) == 0:
                  print(f"::warning file={p}::tags should be a non-empty list")
          sys.exit(1 if missing_any else 0)
          PY
